function CreateFunction(proto, jsfn, length) {
	if (proto === undefined)
		proto = FunctionProto;
	var obj = CreateObject(proto);
	FunctionInit(obj, jsfn, length);
	return obj;
}

function FunctionInit(obj, jsfn, length) {
	if (typeof jsfn != 'function')
		throw new TypeError('Function expected');
	if (length === undefined)
		length = jsfn.length;
	else
		length = ToNumber(length) >>> 0;
	obj.Function = jsfn;
	define(obj.Value, 'length', {
		value: length,
		writable: true,
		enumerable: false,
		configurable: true
	});
}

function IsCallable(value) {
	if (!IsObject(value))
		return false;
	var F = value.Function;
	return typeof F == 'function';
}

// args should always be a native JS array (or undefined)
function Call(f, receiver, args) {
	var F = GetFunction(f);
	if (args !== undefined) {
		if (!isArray(args))
			throw new TypeError('Native JS Array expected');
	}
	return apply(F, receiver, args);
}

function GetFunction(F) {
	var f;
	if (!IsObject(F))
		throw new TypeError('Function expected');
	f = F.Function;
	if (typeof f != 'function')
		throw new TypeError('Function expected');
	return f;
}

function CallMethod(obj, prop, args) {
	var P, F;
	if (!IsObject(obj))
		throw new TypeError('Object expected');
	P = ToString(prop);
	F = Get(obj, P);
	return Call(F, obj, args);
}

function CallOwnMethod(obj, prop, args) {
	var P;
	if (!IsObject(obj))
		throw new TypeError('Object expected');
	P = ToString(prop);
	if (!hasOwn(obj, P))
		throw new TypeError('Object has no method "' + P + '"');
	return CallMethod(obj, P, args);
}

function Bind(obj, receiver) {
	var f = GetFunction(obj),
		bound;
	if (arguments.length == 1)
	 	bound = lazyBind(f);
	else
		bound = lazyBind(f, receiver);
	return CreateFunction(FunctionProto, bound, f.length + 1);
}

function AsCoercive(f, nilable) {
	if (!IsCallable(f))
		throw new TypeError('Function expected');
	if (nilable)
		return CreateFunction(null, function(value) {
			if (value === null || value === undefined)
				return undefined;
			return Call(f, undefined, [ value ]);
		}, 1);
	return f;
}

function PartiallyApply(f, appliedArgs) {
	if (!IsCallable(f))
		throw new TypeError('Function expected');
	if (!isArray(appliedArgs))
		throw new TypeError('Array expected');
	return CreateFunction(undefined, function() {
		var args = create(null),
			unusedIndices = create(null),
			unusedCollapsed = create(null),
			arg, slot, unused, i, j, insert;
		args.length = 0;
		for (i = 0; i < arguments.length; i++)
			unusedIndices[i] = true;
		unusedIndices.length = arguments.length;
		unusedCollapsed.length = 0;
		// First pass: Replace slots that are explicit indices and note which
		// ones have been used.
		for (i = 0; i < appliedArgs.length; i++) {
			arg = appliedArgs[i];
			if (IsWrapper(arg) && 'Slot' in arg) {
				slot = arg.Slot;
				if (typeof slot == 'number') {
					if (sign(slot) == -1)
						slot = arguments.length - 1 + slot;
					unusedIndices[slot] = false;
					push(args, arguments[slot]);
				}
				else if (slot === null || IsObject(slot) && 'RangeFrom' in slot)
					push(args, arg);
				else
					throw new Error('Invalid slot value');
			}
			else
				push(args, arg);
		}
		// Collapse unusedIndices array
		for (i = 0; i < unusedIndices.length; i++)
			if (unusedIndices[i])
				push(unusedCollapsed, i);
		// Second pass: Fill in implicit slots
		for (i = 0; i < args.length; i++) {
			arg = args[i];
			if (IsWrapper(arg) && 'Slot' in arg) {
				slot = arg.Slot;
				if (slot === null) {
					j = shift(unusedCollapsed);
					args[i] = arguments[j];
					unusedIndices[j] = false;
				}
				else if (!IsObject(slot) || !('RangeFrom' in slot))
					throw new Error('Unexpected slot value');
			}
		}
		// Fill in range slots
		for (i = 0; i < args.length; i++) {
			arg = args[i];
			if (IsWrapper(arg) && 'Slot' in arg) {
				insert = PartiallyApplyRange(
					arg.Slot, arguments, unusedIndices
				);
				spliceAll(args, i, 1, insert);
				i += insert.length - 1;
			}
		}
		Call(f, this, slice(args));
	}, appliedArgs.length);
	// TODO: Enforce only one rest slot permitted (in parser)
}

function PartiallyApplyRange(range, args, unusedIndices) {
	var insert = create(null),
		// It's okay that from and to are coerced to integers because it can
		// still simulate an iteratable where each value that is produced by
		// the iterable is 
		from = ToIndex(range.RangeFrom, args.length),
		to = ToIndex(range.RangeTo, args.length),
		i, L;
	insert.length = 0;
	from = min(max(from, 0), args.length);
	to = min(max(to, 0), args.length);
	for (i = from; from < to ? i < to : i > to; from < to ? i++ : i--)
		if (unusedIndices[i]) {
			push(insert, args[i]);
			unusedIndices[i] = false;
		}
	return insert;
}