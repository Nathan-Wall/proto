// fn getDescriptor(obj, key) :{
// 	return P.GetDescriptor(obj, key);
// }

// fn getOwnDescriptor(obj, key) :{
// 	return P.GetOwnDescriptor(obj, key);
// }

// fn has(obj, key) :{
// 	// TODO: make sure in operator calls ToString() on left operand and converts
// 	// right operand to JS object
// 	return key in obj;
// }

// fn hasOwn(obj, key) :{
// 	return P.HasOwn(obj, key);
// }

// fn isCallable(value) :{
// 	return P.IsCallable(value);
// }

// fn keys(value) :{
// 	// TODO: make shortcut in transpiler for this form and the #{ } form, for
// 	// performance
// 	var k = #[ ],
// 		ks,
// 		p = value,
// 		i = 0;
// 	do :{
// 		ks = P.GetOwnKeys(p);
// 		for j of 0..ks.length:
// 			k[i++] = ks[j];
// 	} while p = P.GetPrototype(p);
// 	k.length = i;
// 	return P.CreateArray(Array, k);
// }

// fn ownKeys(value) :{
// 	return P.GetOwnKeys(value);
// }

// fn isObject(value) :{
// 	return P.IsObject(value);
// }

// fn define(obj, key, desc) :{
// 	// Note: It makes sense for Proto to examine inherited properties in the
// 	// descriptors, although it doesn't for JS, because it's trivial to create
// 	// dictionaries in Proto.
// 	// TODO
// }

// reflect := #{
// 	getDescriptor, getOwnDescriptor, has, hasOwn, isCallable,
// 	keys, ownKeys, isObject
// };